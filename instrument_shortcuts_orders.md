Analyzing the API requirements and mapping them to our database models:


[3 tools called]

Based on the DhanHQ order placement API and the codebase, here's what's required and calculated:

## Required fields from Instrument/Derivative tables

### 1. From Instrument or Derivative table:
- `securityId` (REQUIRED)
  - Source: `Instrument.security_id` or `Derivative.security_id`
  - Used for: Identifying the instrument in the API call
  - Currently: Retrieved from `Derivative` selected by `Options::ChainAnalyzer.pick_strikes`

- `exchangeSegment` (REQUIRED)
  - Source: `Instrument.exchange_segment` or `Derivative.exchange_segment` (or derived from `exchange` + `segment`)
  - Values: `NSE_FNO`, `NSE_EQ`, `IDX_I`, `BSE_FNO`, etc.
  - Currently: Retrieved from `Derivative` via `Options::ChainAnalyzer.pick_strikes` (returns `segment:`)
  - Note: For exit orders, the segment comes from `PositionTracker.segment` or the instrument

### 2. Not in DB (provided/calculated):
- `quantity` (REQUIRED)
  - Calculated by: `Capital::Allocator.qty_for()`
  - Inputs:
    - `entry_price` (from option pick `ltp`)
    - `derivative_lot_size` (from `Derivative.lot_size`)
    - `index_cfg[:capital_alloc_pct]` or capital band policy
    - Available cash from DhanHQ Funds API
  - Must be a multiple of `lot_size`

- `transactionType` (REQUIRED)
  - Values: `BUY` or `SELL`
  - Entry: `BUY` (via `Orders::Placer.buy_market!`)
  - Exit: `SELL` for LONG positions (via `Orders::Placer.exit_position!`)

- `productType` (REQUIRED)
  - Current: Hardcoded to `INTRADAY` in `Orders::Placer.buy_market!`
  - For exit: Fetched from position details via `fetch_position_details()`
  - Possible values: `INTRADAY`, `CNC`, `MARGIN`, `MTF`, `CO`, `BO`

- `orderType` (REQUIRED)
  - Current: Hardcoded to `MARKET` in `Orders::Placer.buy_market!`
  - Possible values: `MARKET`, `LIMIT`, `STOP_LOSS`, `STOP_LOSS_MARKET`

- `validity` (REQUIRED)
  - Current: Hardcoded to `DAY` in `Orders::Placer.buy_market!`
  - Possible values: `DAY`, `IOC`

- `correlationId` / `clientOrderId`
  - Generated by: `Entries::EntryGuard.build_client_order_id()`
  - Format: `AS-{KEY}-{SID}-{TIMESTAMP}` (truncated to 30 chars)

- `price` (Required for LIMIT orders)
  - For MARKET orders: Empty or `nil`
  - For LIMIT orders: Calculated/retrieved (e.g., from LTP or entry price)

- `disclosedQuantity` (Optional)
  - Current: Set to `0` in `Orders::Placer.buy_market!`
  - Note: API requires >30% of quantity if provided

- `triggerPrice` (Conditional - for STOP_LOSS orders)
  - Not currently used in market orders
  - Would be calculated for stop-loss orders based on entry price and SL%

## Current implementation flow

### Entry Order (BUY):
```ruby
# 1. Strike Selection (Options::ChainAnalyzer)
pick = Options::ChainAnalyzer.pick_strikes(...)
  # Returns: { segment:, security_id:, lot_size:, ... }

# 2. Position Sizing (Capital::Allocator)
quantity = Capital::Allocator.qty_for(
  index_cfg: index_cfg,
  entry_price: pick[:ltp],
  derivative_lot_size: pick[:lot_size]
)

# 3. Order Placement (Orders::Placer)
Orders::Placer.buy_market!(
  seg: pick[:segment],        # From Derivative
  sid: pick[:security_id],    # From Derivative
  qty: quantity,               # Calculated
  client_order_id: correlation_id, # Generated
  product_type: 'INTRADAY'    # Hardcoded
)
```

### Exit Order (SELL):
```ruby
# 1. Fetch Position Details (from DhanHQ API)
position_details = fetch_position_details(security_id)
  # Returns: { product_type:, net_qty:, exchange_segment:, ... }

# 2. Order Placement (Orders::Placer)
Orders::Placer.exit_position!(
  seg: position_details[:exchange_segment], # From position
  sid: security_id,                         # From PositionTracker
  client_order_id: correlation_id           # Generated
)
```

## Summary table

| API Field | Required | Source | Current Implementation |
|-----------|----------|--------|----------------------|
| `securityId` | ✅ Yes | `Derivative.security_id` or `Instrument.security_id` | ✅ From `Options::ChainAnalyzer.pick_strikes` |
| `exchangeSegment` | ✅ Yes | `Derivative.exchange_segment` or `Instrument.exchange_segment` | ✅ From `Options::ChainAnalyzer.pick_strikes` or `PositionTracker` |
| `quantity` | ✅ Yes | **Calculated** via `Capital::Allocator.qty_for()` | ✅ Uses `lot_size` from Derivative |
| `transactionType` | ✅ Yes | **Determined** by trading logic (BUY/SELL) | ✅ Hardcoded to `BUY` for entries |
| `productType` | ✅ Yes | **Configuration** (INTRADAY/CNC/etc) | ✅ Hardcoded to `INTRADAY` |
| `orderType` | ✅ Yes | **Configuration** (MARKET/LIMIT/etc) | ✅ Hardcoded to `MARKET` |
| `validity` | ✅ Yes | **Configuration** (DAY/IOC) | ✅ Hardcoded to `DAY` |
| `correlationId` | ✅ Yes | **Generated** via `EntryGuard.build_client_order_id()` | ✅ Format: `AS-{KEY}-{SID}-{TIMESTAMP}` |
| `dhanClientId` | ✅ Yes | **From DhanHQ API config** | ✅ Handled by `DhanHQ::Models::Order.create` |
| `price` | ⚠️ Conditional | **Market price** or calculated | ❌ Not used (MARKET orders) |
| `disclosedQuantity` | ❌ Optional | **Calculated** (set to 0) | ✅ Set to `0` |
| `triggerPrice` | ❌ Conditional | **Calculated** for stop-loss | ❌ Not used (MARKET orders) |

## Recommendations

1. Store `exchange_segment` explicitly in `Derivative`:
   - Currently relies on fallback to `instrument.exchange_segment`
   - Explicitly store it in `Derivative.exchange_segment` for consistency

2. Make `productType` configurable:
   - Currently hardcoded to `INTRADAY`
   - Consider storing in `Instrument` or making it configurable per index

3. Add `lot_size` validation:
   - Ensure `quantity` is always a multiple of `lot_size`
   - Currently handled in `Capital::Allocator`, but explicit validation is helpful

4. Consider storing `correlationId` mapping:
   - Track `correlationId` → `order_no` mapping for order tracking
   - Currently stored in Rails cache for duplicate prevention only

The current implementation covers the required fields, with segment and security_id sourced from the `Derivative` selected by the chain analyzer.