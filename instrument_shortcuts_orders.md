
Given this Order placement api documentation identify what all is required from the instrument or derivatives table to place and buy/sell order and what needs to be calculated?

Order Placement
The order request API lets you place new orders.


    curl --request POST \
    --url https://api.dhan.co/v2/orders \
    --header 'Content-Type: application/json' \
    --header 'access-token: JWT' \
    --data '{Request JSON}'

Request Structure


    {
        "dhanClientId":"1000000003",
        "correlationId":"123abc678",
        "transactionType":"BUY",
        "exchangeSegment":"NSE_EQ",
        "productType":"INTRADAY",
        "orderType":"MARKET",
        "validity":"DAY",
        "securityId":"11536",
        "quantity":"5",
        "disclosedQuantity":"",
        "price":"",
        "triggerPrice":"",
        "afterMarketOrder":false,
        "amoTime":"",
        "boProfitValue":"",
        "boStopLossValue": ""
    }

Parameters

Field	Type	Description
dhanClientId
required	string	User specific identification generated by Dhan
correlationId	string	The user/partner generated id for tracking back.
transactionType
required	enum string	The trading side of transaction
BUY  SELL
exchangeSegment
required	enum string	Exchange Segment of instrument to be subscribed as found in Annexure
productType
required	enum string	Product type
CNC  INTRADAY MARGIN MTF  CO BO
orderType
required	enum string	Order Type
LIMIT  MARKET  STOP_LOSS  STOP_LOSS_MARKET
validity
required	enum string	Validity of Order
DAY IOC
securityId
required	string	Exchange standard ID for each scrip. Refer here
quantity
required	int	Number of shares for the order
disclosedQuantity	int	Number of shares visible (Keep more than 30% of quantity)
price
required	float	Price at which order is placed
triggerPrice
conditionally required	float	Price at which the order is triggered, in case of SL-M & SL-L
afterMarketOrder
conditionally required	boolean	Flag for orders placed after market hours
amoTime
conditionally required	enum sting	Timing to pump the after market order
PRE_OPEN OPEN OPEN_30 OPEN_60
boProfitValue
conditionally required	float	Bracket Order Target Price change
boStopLossValue
conditionally required	float	Bracket Order Stop Loss Price change

Response Structure


{
    "orderId": "112111182198",
    "orderStatus": "PENDING",
}

Parameters

Field	Type	Description
orderId	string	Order specific identification generated by Dhan
orderStatus	enum string	Last updated status of the order
TRANSIT PENDING REJECTED CANCELLED TRADED EXPIRED





---

## üéØ **Quick Summary**

### **Recommended Approach: Use Convenience Methods**

The system provides convenient model-level methods that automatically handle all database field extraction and calculations:

```ruby
# For derivatives (options)
derivative.buy_option!(qty: nil, index_cfg: { key: 'NIFTY' })
derivative.sell_option!(qty: nil)

# For instruments (indices/futures)
instrument.buy_market!(qty: 1)
instrument.sell_market!(qty: nil)

# Or use the admin facade
Trading::AdminActions.buy_derivative!(derivative_id: 123, qty: 50)
```

**These methods automatically:**
- Extract `security_id` and `exchangeSegment` from database
- Calculate `quantity` using `Capital::Allocator` (if needed)
- Resolve LTP from cache or meta
- Create PositionTracker for tracking
- Subscribe to WebSocket feeds
- Handle all API field mapping

**Database Fields Required:**
- `security_id` (from `Derivative` or `Instrument`)
- `exchange` + `segment` (to derive `exchangeSegment`)
- `lot_size` (from `Derivative` for quantity validation)

---

## Analysis: DhanHQ Order Placement API Requirements

### üìã **1. REQUIRED Fields from Database (Instrument/Derivative Tables)**

#### ‚úÖ **Direct Database Fields:**

| API Field         | DB Source    | Table                          | Column                                                               | Notes                              |
| ----------------- | ------------ | ------------------------------ | -------------------------------------------------------------------- | ---------------------------------- |
| `securityId`      | **REQUIRED** | `derivatives` or `instruments` | `security_id`                                                        | Exchange standard ID for the scrip |
| `exchangeSegment` | **REQUIRED** | `derivatives` or `instruments` | **Derived** from `exchange` + `segment` OR stored `exchange_segment` | See mapping below                  |

#### üîÑ **Exchange Segment Mapping:**

The `exchangeSegment` API field is constructed from database fields:

**For Derivatives:**
- Source: `Derivative.exchange` + `Derivative.segment` (via `InstrumentHelpers#exchange_segment` method)
- OR: Directly from `Derivative.exchange_segment` if stored
- Mapping logic:
  ```ruby
  # From app/models/concerns/instrument_helpers.rb
  case [exchange&.to_sym, segment&.to_sym]
  when [:nse, :derivatives]  ‚Üí 'NSE_FNO'
  when [:bse, :derivatives]  ‚Üí 'BSE_FNO'
  when [:nse, :equity]       ‚Üí 'NSE_EQ'
  when [:bse, :equity]       ‚Üí 'BSE_EQ'
  when [:nse, :index]        ‚Üí 'IDX_I'
  when [:bse, :index]        ‚Üí 'IDX_I'
  when [:nse, :currency]      ‚Üí 'NSE_CURRENCY'
  when [:bse, :currency]     ‚Üí 'BSE_CURRENCY'
  when [:mcx, :commodity]    ‚Üí 'MCX_COMM'
  ```

**For Instruments:**
- Source: `Instrument.exchange` + `Instrument.segment` (both required fields)
- Same mapping logic applies

#### üìä **Supporting Fields Used for Calculations:**

| DB Field    | Table         | Used For                                       |
| ----------- | ------------- | ---------------------------------------------- |
| `lot_size`  | `derivatives` | Validates `quantity` is a multiple of lot size |
| `tick_size` | `derivatives` | Price precision (optional, for LIMIT orders)   |

---

### üßÆ **2. CALCULATED Fields (Not from DB)**

#### ‚úÖ **Required Calculations:**

| API Field      | Calculation Method             | Inputs Required                                                                                                                                               | Current Implementation                                |
| -------------- | ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------- |
| `quantity`     | `Capital::Allocator.qty_for()` | ‚Ä¢ `entry_price` (from option chain LTP)<br>‚Ä¢ `derivative_lot_size` (from DB)<br>‚Ä¢ `index_cfg[:capital_alloc_pct]`<br>‚Ä¢ Available cash (from DhanHQ Funds API) | ‚úÖ Implemented<br>‚úÖ Must be multiple of `lot_size`     |
| `price`        | For LIMIT orders only          | ‚Ä¢ Current LTP or calculated limit price<br>‚Ä¢ Market price from tick data                                                                                      | ‚ö†Ô∏è Only used for LIMIT orders (currently using MARKET) |
| `triggerPrice` | For STOP_LOSS orders           | ‚Ä¢ Entry price<br>‚Ä¢ Stop loss percentage<br>‚Ä¢ Price direction                                                                                                  | ‚ùå Not used (MARKET orders only)                       |

#### ‚öôÔ∏è **Optional/Conditional Calculations:**

| API Field           | Condition           | Calculation                    | Current Status |
| ------------------- | ------------------- | ------------------------------ | -------------- |
| `disclosedQuantity` | Optional            | Set to `0` or >30% of quantity | ‚úÖ Set to `0`   |
| `boProfitValue`     | Bracket Orders (BO) | Target price calculation       | ‚ùå Not used     |
| `boStopLossValue`   | Bracket Orders (BO) | Stop loss calculation          | ‚ùå Not used     |

---

### üîß **3. DETERMINED/CONFIGURED Fields (Not from DB, Not Calculated)**

#### ‚úÖ **Required Configuration:**

| API Field         | Source            | Current Value                  | Possible Values                                    | Current Implementation                      |
| ----------------- | ----------------- | ------------------------------ | -------------------------------------------------- | ------------------------------------------- |
| `transactionType` | Trading logic     | `BUY` (entry) or `SELL` (exit) | `BUY`, `SELL`                                      | ‚úÖ Determined by order side                  |
| `productType`     | Configuration     | `INTRADAY`                     | `INTRADAY`, `CNC`, `MARGIN`, `MTF`, `CO`, `BO`     | ‚ö†Ô∏è Hardcoded to `INTRADAY`                   |
| `orderType`       | Configuration     | `MARKET`                       | `MARKET`, `LIMIT`, `STOP_LOSS`, `STOP_LOSS_MARKET` | ‚ö†Ô∏è Hardcoded to `MARKET`                     |
| `validity`        | Configuration     | `DAY`                          | `DAY`, `IOC`                                       | ‚ö†Ô∏è Hardcoded to `DAY`                        |
| `dhanClientId`    | DhanHQ API config | From credentials               | User-specific ID                                   | ‚úÖ Handled by `DhanHQ::Models::Order.create` |

#### üÜî **Generated Fields:**

| API Field       | Generation Method                             | Format                                               | Current Implementation |
| --------------- | --------------------------------------------- | ---------------------------------------------------- | ---------------------- |
| `correlationId` | `Entries::EntryGuard.build_client_order_id()` | `AS-{KEY}-{SID}-{TIMESTAMP}` (truncated to 30 chars) | ‚úÖ Implemented          |

#### ‚è∞ **Conditional Fields:**

| API Field          | Condition                    | Values                                   | Current Status |
| ------------------ | ---------------------------- | ---------------------------------------- | -------------- |
| `afterMarketOrder` | After market hours           | `true`/`false`                           | ‚ùå Not used     |
| `amoTime`          | If `afterMarketOrder` = true | `PRE_OPEN`, `OPEN`, `OPEN_30`, `OPEN_60` | ‚ùå Not used     |

## Current implementation flow

### **Method 1: Using Convenience Helpers (Recommended)**

The system provides convenient model-level methods that abstract away the complexity:

#### **Entry Order (BUY) - Derivative:**
```ruby
# Direct model helper - automatically handles all database fields and calculations
derivative = Derivative.find(123)
order = derivative.buy_option!(
  qty: nil,                    # Auto-calculated via Capital::Allocator if nil
  product_type: 'INTRADAY',
  index_cfg: { key: 'NIFTY', segment: 'IDX_I' },
  meta: { ltp: 120.5 }         # Optional: provide LTP or fetch from Redis cache
)

# Behind the scenes, this:
# 1. Gets security_id from derivative.security_id (DB)
# 2. Gets exchangeSegment from derivative.exchange_segment (DB - derived)
# 3. Gets lot_size from derivative.lot_size (DB)
# 4. Calculates quantity via Capital::Allocator.qty_for()
# 5. Resolves LTP from meta or Redis cache
# 6. Places order via Orders.config.place_market()
# 7. Creates PositionTracker automatically
# 8. Subscribes to WebSocket feed
```

#### **Entry Order (BUY) - Instrument:**
```ruby
# For underlying indices or futures
instrument = Instrument.find(456)
order = instrument.buy_market!(
  qty: 1,                      # Defaults to 1 if not provided
  product_type: 'INTRADAY',
  meta: { ltp: 200.5 }
)

# Behind the scenes:
# 1. Gets security_id from instrument.security_id (DB)
# 2. Gets exchangeSegment from instrument.exchange_segment (DB - derived)
# 3. Places order and creates PositionTracker
```

#### **Exit Order (SELL):**
```ruby
# Derivative exit
derivative.sell_option!(qty: nil)  # Auto-uses PositionTracker quantity

# Instrument exit
instrument.sell_market!(qty: nil)   # Auto-uses PositionTracker quantity

# Behind the scenes:
# 1. Fetches active PositionTracker(s) for security_id
# 2. Sums quantity from trackers
# 3. Gets exchangeSegment from tracker or instrument
# 4. Places SELL order via Orders.config.place_market()
```

#### **Using Admin Actions Facade:**
```ruby
# High-level facade for console/controllers
Trading::AdminActions.buy_derivative!(
  derivative_id: 123,
  qty: 50,
  index_key: 'NIFTY'
)

Trading::AdminActions.sell_derivative!(derivative_id: 123)
```

---

### **Method 2: Direct Service Calls (Legacy/Low-Level)**

For more control or programmatic usage:

#### **Entry Order (BUY):**
```ruby
# 1. Strike Selection (Options::ChainAnalyzer)
pick = Options::ChainAnalyzer.pick_strikes(...)
  # Returns: { segment:, security_id:, lot_size:, ... }

# 2. Position Sizing (Capital::Allocator)
quantity = Capital::Allocator.qty_for(
  index_cfg: index_cfg,
  entry_price: pick[:ltp],
  derivative_lot_size: pick[:lot_size]  # From Derivative.lot_size (DB)
)

# 3. Order Placement (Orders::Placer)
Orders::Placer.buy_market!(
  seg: pick[:segment],              # From Derivative (via exchange_segment)
  sid: pick[:security_id],          # From Derivative.security_id (DB)
  qty: quantity,                     # Calculated
  client_order_id: correlation_id,  # Generated
  product_type: 'INTRADAY'
)
```

#### **Exit Order (SELL):**
```ruby
# 1. Fetch Position Details (from DhanHQ API)
position_details = fetch_position_details(security_id)
  # Returns: { product_type:, net_qty:, exchange_segment:, ... }

# 2. Order Placement (Orders::Placer)
Orders::Placer.exit_position!(
  seg: position_details[:exchange_segment], # From position
  sid: security_id,                         # From PositionTracker
  client_order_id: correlation_id           # Generated
)
```

---

### **Helper Methods in InstrumentHelpers**

The convenience methods rely on helper methods that handle database field extraction:

| Helper Method                                     | Purpose                               | Uses DB Fields                           |
| ------------------------------------------------- | ------------------------------------- | ---------------------------------------- |
| `resolve_ltp(segment:, security_id:, meta:)`      | Resolves LTP from meta or Redis cache | Uses `segment` and `security_id`         |
| `exchange_segment`                                | Derives API segment from DB fields    | `exchange` + `segment` ‚Üí `NSE_FNO`, etc. |
| `default_client_order_id(side:, security_id:)`    | Generates correlation ID              | Uses `security_id`                       |
| `ensure_ws_subscription!(segment:, security_id:)` | Ensures WebSocket subscription        | Uses `segment` and `security_id`         |
| `after_order_track!(...)`                         | Creates PositionTracker after order   | Uses `segment`, `security_id`, `symbol`  |

---

## üìä **Quick Reference: Complete Field Mapping**

### **Summary Table**

| API Field           | Required          | Source Type      | DB Source (if applicable)                                                 | Calculation/Config                               | Current Status                               |
| ------------------- | ----------------- | ---------------- | ------------------------------------------------------------------------- | ------------------------------------------------ | -------------------------------------------- |
| `securityId`        | ‚úÖ **Yes**         | **DB**           | `Derivative.security_id`<br>or `Instrument.security_id`                   | -                                                | ‚úÖ From `Options::ChainAnalyzer.pick_strikes` |
| `exchangeSegment`   | ‚úÖ **Yes**         | **DB (derived)** | `Derivative.exchange` + `segment`<br>OR `Instrument.exchange` + `segment` | Derived via `InstrumentHelpers#exchange_segment` | ‚úÖ Mapped from DB fields                      |
| `quantity`          | ‚úÖ **Yes**         | **Calculated**   | Uses `Derivative.lot_size`                                                | `Capital::Allocator.qty_for()`                   | ‚úÖ Implemented                                |
| `transactionType`   | ‚úÖ **Yes**         | **Determined**   | -                                                                         | `BUY` or `SELL` based on order side              | ‚úÖ Working                                    |
| `productType`       | ‚úÖ **Yes**         | **Config**       | -                                                                         | Currently `INTRADAY` (hardcoded)                 | ‚ö†Ô∏è Hardcoded                                  |
| `orderType`         | ‚úÖ **Yes**         | **Config**       | -                                                                         | Currently `MARKET` (hardcoded)                   | ‚ö†Ô∏è Hardcoded                                  |
| `validity`          | ‚úÖ **Yes**         | **Config**       | -                                                                         | Currently `DAY` (hardcoded)                      | ‚ö†Ô∏è Hardcoded                                  |
| `correlationId`     | ‚úÖ **Yes**         | **Generated**    | -                                                                         | `EntryGuard.build_client_order_id()`             | ‚úÖ Implemented                                |
| `dhanClientId`      | ‚úÖ **Yes**         | **Config**       | -                                                                         | From DhanHQ credentials                          | ‚úÖ Handled by API client                      |
| `price`             | ‚ö†Ô∏è **Conditional** | **Calculated**   | Uses market LTP                                                           | Required for LIMIT orders                        | ‚ùå Not used (MARKET only)                     |
| `disclosedQuantity` | ‚ùå Optional        | **Config**       | -                                                                         | Set to `0`                                       | ‚úÖ Set to `0`                                 |
| `triggerPrice`      | ‚ö†Ô∏è **Conditional** | **Calculated**   | -                                                                         | Required for STOP_LOSS orders                    | ‚ùå Not used                                   |
| `afterMarketOrder`  | ‚ö†Ô∏è **Conditional** | **Config**       | -                                                                         | `true`/`false`                                   | ‚ùå Not used                                   |
| `amoTime`           | ‚ö†Ô∏è **Conditional** | **Config**       | -                                                                         | If AMO: `PRE_OPEN`, `OPEN`, etc.                 | ‚ùå Not used                                   |
| `boProfitValue`     | ‚ö†Ô∏è **Conditional** | **Calculated**   | -                                                                         | For Bracket Orders only                          | ‚ùå Not used                                   |
| `boStopLossValue`   | ‚ö†Ô∏è **Conditional** | **Calculated**   | -                                                                         | For Bracket Orders only                          | ‚ùå Not used                                   |

### **Legend:**
- ‚úÖ **Yes** = Required and implemented
- ‚ö†Ô∏è **Conditional** = Required only in specific scenarios
- ‚ùå **Optional** = Optional field

---

## üí° **Key Takeaways**

### **‚úÖ What's Required from Database:**

1. **`security_id`** - Direct from `Derivative` or `Instrument` table
2. **`exchange` + `segment`** - Combined to derive `exchangeSegment` API field
   - OR use stored `exchange_segment` if available
3. **`lot_size`** - Used for quantity validation (must be multiple of lot size)

### **üßÆ What Needs Calculation:**

1. **`quantity`** - Calculated by `Capital::Allocator.qty_for()` using:
   - Entry price (LTP from option chain)
   - Lot size (from DB)
   - Capital allocation percentage (config)
   - Available funds (from DhanHQ API)
2. **`price`** - Only for LIMIT orders (currently not used - MARKET orders only)
3. **`triggerPrice`** - Only for STOP_LOSS orders (currently not used)

### **‚öôÔ∏è What's Determined/Configured:**

1. **`transactionType`** - `BUY` or `SELL` (based on order side)
2. **`productType`** - Currently hardcoded to `INTRADAY`
3. **`orderType`** - Currently hardcoded to `MARKET`
4. **`validity`** - Currently hardcoded to `DAY`
5. **`correlationId`** - Generated by `EntryGuard.build_client_order_id()`

---

## üìù **Recommendations**

### **1. Database Improvements:**
- ‚úÖ **Store `exchange_segment` explicitly in `Derivative` table:**
  - Currently relies on `InstrumentHelpers#exchange_segment` method which derives from `exchange` + `segment`
  - Storing it explicitly would improve performance and clarity
  - Can be populated during instrument import

### **2. Configuration Enhancements:**
- ‚ö†Ô∏è **Make `productType` configurable:**
  - Currently hardcoded to `INTRADAY` in `Orders::Placer.buy_market!`
  - Consider adding to `config/algo.yml` per index or instrument
  - Allow override per instrument type (equity vs derivatives)

- ‚ö†Ô∏è **Make `orderType` configurable:**
  - Currently hardcoded to `MARKET`
  - Add support for `LIMIT` orders with price calculation
  - Consider adding to trading config

- ‚ö†Ô∏è **Make `validity` configurable:**
  - Currently hardcoded to `DAY`
  - Consider `IOC` for immediate execution scenarios

### **3. Validation Enhancements:**
- ‚úÖ **Explicit `lot_size` validation:**
  - Ensure `quantity` is always a multiple of `lot_size`
  - Currently handled in `Capital::Allocator`, but add explicit validation in `Orders::Placer`

### **4. Tracking & Monitoring:**
- üìä **Store `correlationId` ‚Üí `order_no` mapping:**
  - Currently stored in Rails cache for duplicate prevention only
  - Consider creating an `Order` model to track:
    - `correlation_id` (client order ID)
    - `order_no` (DhanHQ order ID)
    - `status`, `security_id`, `quantity`, etc.
  - Enables better order tracking and reconciliation

### **5. Future Features:**
- üîÆ **Support for LIMIT orders:**
  - Calculate `price` field based on LTP ¬± offset
  - Use `tick_size` from database for price precision

- üîÆ **Support for STOP_LOSS orders:**
  - Calculate `triggerPrice` based on entry price and SL percentage
  - Implement trailing stop logic

- üîÆ **Support for Bracket Orders:**
  - Calculate `boProfitValue` and `boStopLossValue`
  - Implement bracket order management

---

## ‚úÖ **Conclusion**

**Current Implementation Status:**
- ‚úÖ All **required** fields from database are properly sourced (`securityId`, `exchangeSegment`)
- ‚úÖ All **required** calculated fields are implemented (`quantity` via `Capital::Allocator`)
- ‚úÖ All **required** configuration fields are set (though hardcoded)
- ‚úÖ **Convenience methods** added for simplified order placement (`Derivative#buy_option!`, `Instrument#buy_market!`, etc.)
- ‚úÖ **Automatic tracking** - PositionTracker creation and WebSocket subscription handled automatically
- ‚ö†Ô∏è Several **conditional** fields are not implemented (LIMIT, STOP_LOSS, BO orders)
- ‚úÖ Basic MARKET order placement is fully functional

**The system successfully places MARKET orders using:**

### **Via Convenience Methods (Recommended):**
1. **Database fields** extracted automatically:
   - `security_id` from `Derivative.security_id` or `Instrument.security_id`
   - `exchangeSegment` derived from `exchange` + `segment` fields
   - `lot_size` from `Derivative.lot_size` (for quantity validation)
2. **Calculated `quantity`** via `Capital::Allocator.qty_for()` (if not provided)
3. **LTP resolution** from `meta[:ltp]` or Redis cache
4. **Automatic tracking** - PositionTracker creation, WebSocket subscription, cache clearing
5. **Generated `correlationId`** via `default_client_order_id()` helper
6. **Hardcoded but functional** configuration (`INTRADAY`, `MARKET`, `DAY`)

### **Via Direct Service Calls:**
1. `security_id` and `exchange_segment` from `Derivative` table
2. Calculated `quantity` respecting lot size constraints
3. Generated `correlationId` for order tracking
4. Hardcoded but functional configuration (`INTRADAY`, `MARKET`, `DAY`)

**Key Improvements with Convenience Methods:**
- ‚úÖ Simplified API - no need to manually extract database fields
- ‚úÖ Automatic PositionTracker management
- ‚úÖ Automatic WebSocket subscription for real-time updates
- ‚úÖ Automatic Redis cache management
- ‚úÖ Consistent with algorithmic entry flow
- ‚úÖ Reuses same risk management and tracking infrastructure